#ifndef _DEF_H
#include "def.h"
#endif

void Christoffel(double spin, double defpar[], double w1, double w2, double CS[][4][4]) {
	double rDg[4][4];
	double thDg[4][4];
	double gg;

	metric_rderivatives(spin, defpar,  w1, w2, rDg);
	metric_thderivatives(spin, defpar, w1, w2, thDg);

	double Dg[4][4][4];
	/*----------------initializing Dg----------------------*/
	for (int i = 0; i <= 3; i++) {
		for (int j = 0; j <= 3; j++) {
			for (int k = 0; k <= 3; k++) {
				if (k == 1)
					Dg[i][j][k] = rDg[i][j];
				else {
					if (k == 2)
						Dg[i][j][k] = thDg[i][j];
					else
						Dg[i][j][k] = 0;
				}
			}
		}
	}
	
	double invg[4][4] = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };
	double g[4][4]= { { 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 } };
	metric(spin, defpar, w1, w2, g);
	//metric_inverse(spin, defpar[],  w1, w2, invg);
	gg = g[0][0] * g[3][3] - g[0][3] * g[0][3];
	if (std::fabs(gg) > 1e10) {
		invg[0][0] = g[3][3] / gg;
		invg[0][3] = -g[0][3] / gg;
		invg[1][1] = 1 / g[1][1];
		invg[2][2] = 1 / g[2][2];
		invg[3][0] = invg[0][3];
		invg[3][3] = g[0][0] / gg;
	}
	else metric_inverse(spin, defpar, w1, w2, invg);

	CS[0][0][0] = 0.5* 0;
	CS[0][0][1] = 0.5* (invg[0][0] * Dg[0][0][1] + invg[0][3] * Dg[0][3][1]);
	CS[0][0][2] = 0.5* (invg[0][0] * Dg[0][0][2] + invg[0][3] * Dg[0][3][2]);
	CS[0][0][3] = 0.5* 0;
	CS[0][1][0] = CS[0][0][1];
	CS[0][1][1] = 0.5* 0;
	CS[0][1][2] = 0.5* 0;
	CS[0][1][3] = 0.5* (invg[0][0] * Dg[0][3][1] + invg[0][3] * Dg[3][3][1]);
	CS[0][2][0] = CS[0][0][2];
	CS[0][2][1] = 0.5* 0;
	CS[0][2][2] = 0.5* 0;
	CS[0][2][3] = 0.5* (invg[0][0] * Dg[0][3][2] + invg[0][3] * Dg[3][3][2]);
	CS[0][3][0] = 0.5* 0;
	CS[0][3][1] = CS[0][1][3];
	CS[0][3][2] = CS[0][2][3];
	CS[0][3][3] = 0.5* 0;
				   
	CS[1][0][0] = 0.5* -invg[1][1] * Dg[0][0][1];
	CS[1][0][1] = 0.5* 0;
	CS[1][0][2] = 0.5* 0;
	CS[1][0][3] = 0.5* -invg[1][1] * Dg[0][3][1];
	CS[1][1][0] = 0.5* 0;
	CS[1][1][1] = 0.5* invg[1][1] * Dg[1][1][1];
	CS[1][1][2] = 0.5* invg[1][1] * Dg[1][1][2];
	CS[1][1][3] = 0.5* 0;
	CS[1][2][0] = 0.5* 0;
	CS[1][2][1] = CS[1][1][2];
	CS[1][2][2] = 0.5* -invg[1][1] * Dg[2][2][1];
	CS[1][2][3] = 0.5* 0;
	CS[1][3][0] = CS[1][0][3];
	CS[1][3][1] = 0.5* 0;
	CS[1][3][2] = 0.5* 0;
	CS[1][3][3] = 0.5* -invg[1][1] * Dg[3][3][1];
				   
	CS[2][0][0] = 0.5* -invg[2][2] * Dg[0][0][2];
	CS[2][0][1] = 0.5* 0;
	CS[2][0][2] = 0.5* 0;
	CS[2][0][3] = 0.5* -invg[2][2] * Dg[0][3][2];
	CS[2][1][0] = 0.5* 0;
	CS[2][1][1] = 0.5* -invg[2][2] * Dg[1][1][2];
	CS[2][1][2] = 0.5* invg[2][2] * Dg[2][2][1];
	CS[2][1][3] = 0.5* 0;
	CS[2][2][0] = 0.5* 0;
	CS[2][2][1] = CS[2][1][2];
	CS[2][2][2] = 0.5* invg[2][2] * Dg[2][2][2];
	CS[2][2][3] = 0.5* 0;
	CS[2][3][0] = CS[2][0][3];
	CS[2][3][1] = 0.5* 0;
	CS[2][3][2] = 0.5* 0;
	CS[2][3][3] = 0.5* -invg[2][2] * Dg[3][3][2];
				   
	CS[3][0][0] = 0.5* 0;
	CS[3][0][1] = 0.5* (invg[3][3] * Dg[0][3][1] + invg[3][0] * Dg[0][0][1]);
	CS[3][0][2] = 0.5* (invg[3][3] * Dg[0][3][2] + invg[3][0] * Dg[0][0][2]);
	CS[3][0][3] = 0.5* 0;
	CS[3][1][0] = CS[3][0][1];
	CS[3][1][1] = 0.5* 0;
	CS[3][1][2] = 0.5* 0;
	CS[3][1][3] = 0.5* (invg[3][3] * Dg[3][3][1] + invg[3][0] * Dg[0][3][1]);
	CS[3][2][0] = CS[3][0][2];
	CS[3][2][1] = 0.5* 0;
	CS[3][2][2] = 0.5* 0;
	CS[3][2][3] = 0.5* (invg[3][3] * Dg[3][3][2] + invg[3][0] * Dg[0][3][2]);
	CS[3][3][0] = 0.5* 0;
	CS[3][3][1] = CS[3][1][3];
	CS[3][3][2] = CS[3][2][3];
	CS[3][3][3] = 0.5* 0;
}
